SOLID :

manage most of the software design problems
makes design more understandable, flexible, testable, extensible and maintainable


Solution to develop a successful application depends on:
ARCHITECTURE: Choosing an architecture is the first step in designing an application based on the requirements.
Example: MVC, WEB API, MVVM, etc.
DESIGN PRINCIPLES: Application development process needs to follow the design principles.
DESIGN PATTERNS: We need to choose correct design patterns to build the software.

WITH SOLID:
1. Achieve reduction in complexity of code
2. Increase readability, extensibility and maintenance
3. Reduce errors and implement reusability
4. Achieve better testability

WITHOUT SOLID:
1. End up with tight or strong coupling of the code with many other modules/applications
2. Tight coupling causes more time to implement new requirements, features, or bug fixes, and sometimes creates unknown issues
3. End up with code which is not testable
4.End up with duplication of code
5.End up creating new bugs while fixing another bug


SINGLE RESPONSIBILITY PRINCIPLE
A class should have only one reason to change.
EXAMPLE :
❌ Wrong Example:
class Report:
    def generate_report(self):
        pass
    
    def save_to_file(self):
        pass

Here, the class:
Generates report
Saves file
Two responsibilities ❌

✅ Correct:
class Report:
    def generate_report(self):
        pass

class FileSaver:
    def save_to_file(self, data):
        pass

✔ Now each class has only one job.




OPEN CLOSED PRINCIPLE
Software entities should be open for extension but closed for modification.
You should add new functionality
Without changing existing code
EXAMPLE :
❌ Bad:
class Payment:
    def pay(self, type):
        if type == "upi":
            pass
        elif type == "card":
            pass

Every new payment type → modify class ❌

✅ Good:
class Payment:
    def pay(self):
        pass

class UPI(Payment):
    def pay(self):
        pass

class Card(Payment):
    def pay(self):
        pass

Now new payment → just create new class ✔



LISKOV  SUBSTITUTION PRINCIPLE
Subclasses should be replaceable for their base class without breaking functionality.
EXAMLE :
❌ Bad Example:
class Bird:
    def fly(self):
        pass

class Ostrich(Bird):
    def fly(self):
        raise Exception("Can't fly")

Ostrich breaks expectation ❌

✅ Good Design:
class Bird:
    pass

class FlyingBird(Bird):
    def fly(self):
        pass

class Sparrow(FlyingBird):
    pass

class Ostrich(Bird):
    pass

Now no rule is broken ✔




INTERFACE SEGREGATION PRINCIPLE
Clients should not be forced to depend on methods they don’t use.
❌ Bad:
class Worker:
    def work(self):
        pass
    def eat(self):
        pass

Robot doesn’t eat ❌

✅ Good:
class Workable:
    def work(self):
        pass

class Eatable:
    def eat(self):
        pass

Now classes implement only what they need ✔


DEPENDENCY INVERSION PRINCIPLE
High-level modules should not depend on low-level modules.
Both should depend on abstractions.
❌ Bad:
class MySQLDatabase:
    pass

class App:
    def __init__(self):
        self.db = MySQLDatabase()

App tightly coupled ❌

✅ Good:
class Database:
    def connect(self):
        pass

class MySQLDatabase(Database):
    def connect(self):
        pass

class App:
    def __init__(self, db: Database):
        self.db = db

Now we can pass any database ✔



# SPIKE
It is used to determine how much work will be required to solve or work around a software issue. 
Typically, a "spike test" involves gathering additional information or testing for easily reproduced edge cases. 
The term is used in agile software development approaches like Scrum or Extreme Programming.

A distinction can be made between technical spikes and functional spikes.
The technical spike is used more often for evaluating the impact new technology has on the current implementation. 
A functional spike is used to determine the interaction with a new feature or implementation.
